#version 450

layout (local_size_x = 256) in;

struct ArrayVertex {
    uint id;
    float paintColor[4];
    uint data[4];
    float temperature;
    float velocity[3];
    float position[3];
    uint state;
};

struct GridPoint {
    uint particleOffset;
};

layout (set = 0, binding = 0) readonly buffer ParticleGrid {
    GridPoint[] data;
} grid;

layout (set = 0, binding = 1) buffer Particles {
    ArrayVertex[] data;
} particles;

layout ( push_constant ) uniform SimulationInfo {
    uint xSize;
    uint ySize;
    uint zSize;
    uint particleCount;
    uint updatesPerSecond;
} simulationInfo;

struct ParticleInfoPacket {
    float density;
    uint state; /**
                 * bits 0-1 = State Bits (00b - Solid, 01b - Liquid, 10b - Gas, 11b - Powder)
                 * bit 2 = Affected By Gravity (0b - false, 1b - true)
                 **/
};

layout (set = 0, binding = 2) readonly buffer ParticleInfo {
    ParticleInfoPacket[] data;
} particleInfo;


// Utility functions
uint calculatePosition(uint x, uint y, uint z);
bool checkBounds(uint x, uint y, uint z);
uint getOffset(uint x, uint y, uint z);
bool isEmpty(uint x, uint y, uint z);
ArrayVertex getParticle(uint x, uint y, uint z);
ParticleInfoPacket getParticleInfo(ArrayVertex particle);


#pragma PARTICLE_CODE

void updateParticle(uint globalOffset) {
    ArrayVertex vertex = particles.data[globalOffset];

    switch(vertex.id&0xFFFF) {
        #pragma PARTICLE_SWITCH
        default: break;
    }

    particles.data[globalOffset] = vertex;
}

void main() {
    uint globalId = gl_GlobalInvocationID.x;
    if(globalId >= simulationInfo.particleCount) return;

    updateParticle(globalId);
}


// Utility functions
uint calculatePosition(uint x, uint y, uint z) {
    return x + y*simulationInfo.xSize + z*simulationInfo.xSize*simulationInfo.ySize;
}

bool checkBounds(uint x, uint y, uint z) {
    return x >= 0 && x < simulationInfo.xSize && y >= 0 && y < simulationInfo.ySize && z >= 0 && z < simulationInfo.zSize;
}

uint getOffset(uint x, uint y, uint z) {
    return grid.data[calculatePosition(x, y, z)].particleOffset;
}

bool isEmpty(uint x, uint y, uint z) {
    return getOffset(x, y, z) == 0;
}

ArrayVertex getParticle(uint x, uint y, uint z) {
    return particles.data[getOffset(x, y, z)-1];
}

ParticleInfoPacket getParticleInfo(ArrayVertex particle) {
    return particleInfo.data[(particle.id&0xFFFF)-1];
}